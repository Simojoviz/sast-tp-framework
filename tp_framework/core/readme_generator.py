import logging
import re

from datetime import datetime
from pathlib import Path

from core.exceptions import MeasurementInvalid
from core.measurement import Measurement
from core.readme_markdown_elements import *

from core import utils
from core import loggermgr

logger = logging.getLogger(loggermgr.logger_name(__name__))


class READMEGenerator:
    def __init__(
        self,
        pattern,
        discovery_rule_results: Path | None,
        measurement_results: Path | None,
        masking_file: Path | None,
    ) -> None:
        self.pattern = pattern
        self.discovery_rule_results = discovery_rule_results
        self.measurement_results = measurement_results
        self.mask = {}

        self.log_prefix = f"Generating README for {self.pattern}: "

        try:
            self.discovery_rule_results = utils.read_csv_to_dict(discovery_rule_results)
            self.discovery_rule_results = self.discovery_rule_results[self.pattern.language]
            assert isinstance(self.discovery_rule_results, dict)
        except Exception:
            logger.warning(f"{self.log_prefix}Cannot find discovery rule results for language {self.pattern.language}")
            self.discovery_rule_results = None
            
        if not measurement_results or not measurement_results.is_dir():
            logger.warning(f"{self.log_prefix}Cannot locate `measurement_results` in '{self.measurement_results}'")
            self.measurement_results = None
        
        try:
            self.mask = utils.read_json(masking_file)
        except Exception:
            logger.info(f"{self.log_prefix}Continue without masking.")
            self.mask = {}

        self.readme_structure = [
            self._comment,
            self._heading,
            self._tags,
            self._pattern_description,
            self._pattern_metadata,
            self._instances,
        ]

    def _comment(self) -> list:
        # Generates a Comment for the top of the README file.
        return [
            MarkdownComment(
                "This file is automatically generated. If you wish to make any changes, please use the JSON files and regenerate this file using the tpframework."
            )
        ]

    def _heading(self) -> list:
        # Generates the heading for the README file.
        return [MarkdownHeading(self.pattern.name, 1)]

    def _pattern_description(self) -> list:
        # Generates the description for the pattern.
        _, desc = self.pattern.get_description()
        return [MarkdownHeading("Description", 2), MarkdownString(desc)]

    def _tags(self) -> list:
        # Generates pattern tags.
        return [
            MarkdownString(f'Tags: {", ".join(self.pattern.tags)}'),
            MarkdownString(f'Version: {self.pattern.version}'),
        ]

    def _pattern_metadata(self) -> list:
        # Generates a table of pattern metadata, such as the instances, discovery rule discovery method and if the discovery rule is successfull on the instance.
        discovery_rule_exists = []
        instance_names = []
        discovery_rule_successfull = []
        discovery_method = []
        for instance in self.pattern.instances:
            instance_name = f"{instance.instance_id} Instance"
            instance_names += [MarkdownLink(instance_name, MarkdownHeading(instance_name, 2))]

            discovery_rule_exists += [utils.translate_bool(instance.discovery_rule.is_file())]

            if self.discovery_rule_results:
                try:
                    current_result = self.discovery_rule_results[str(self.pattern.pattern_id)][str(instance.instance_id)]
                except KeyError:
                    logger.warning(f'{self.log_prefix}Could not find discovery rule result for {instance}. Assuming "error"')
                    current_result = "error"
                discovery_rule_successfull += [current_result]
            discovery_method += [instance.discovery_method]

        metadata_dict = {
            "0::Instances": instance_names,
            "1::has discovery rule": discovery_rule_exists,
            "2::discovery method": discovery_method,
            "3::rule successfull": discovery_rule_successfull,
        }
        if not self.discovery_rule_results:
            metadata_dict.pop("3::rule successfull")

        return [MarkdownHeading("Overview", 2), MarkdownTable(metadata_dict)]

    def _instances(self) -> list:
        # Generates the README elements for all instances.
        return InstanceREADMEGenerator(
            self.pattern,
            self.measurement_results,
            mask=self.mask
        ).generate_md()

    def generate_README(self) -> str:
        md_elements = []
        for f in self.readme_structure:
            md_elements += f()
        return MarkdownDocument(md_elements).to_markdown()


class InstanceREADMEGenerator:
    def __init__(
        self,
        pattern,
        path_to_measurements: Path | None,
        level: int = 2,
        mask: dict = {},
    ) -> None:
        self.pattern = pattern
        self.log_prefix = f"Generating README for {self.pattern}: "
        self.level = level
        self.measurements = Path(path_to_measurements) if path_to_measurements else None
        self.has_multiple_instances = len(self.pattern.instances) > 1
        self.mask_dict = mask

        self.current_instance = None

        self.instance_structure = [
            self._instance_name,
            self._instance_description,
            self._instance_code,
            self._instance_properties,
            self._instance_more,
        ]
        self.instance_more_structure = [
            self._compile,
            self._discovery,
            self._measurement,
            self._remediation,
        ]

    def _instance_name(self) -> list:
        # Generates the Markdown heading for the current instance.
        return [MarkdownHeading(f"{self.current_instance.instance_id} Instance", self.level)]

    def _instance_description(self) -> list:
        # Generates the description for the current instance.
        _, desc = self.current_instance.get_description()
        return [MarkdownString(desc)] if desc else []

    def _instance_code(self) -> list:
        # Generates the Instance code for the current instance.
        heading = MarkdownHeading("Code", self.level + 1)
        code = self.current_instance.code_path
        source = self.current_instance.expectation_source_file
        sink = self.current_instance.expectation_sink_file
        if source == sink:
            content = self._get_file_content_if_exists(code)
            return [heading, MarkdownCode(content, self.pattern.language)] if content else []
        source_content = self._get_file_content_if_exists(source)
        sink_content = self._get_file_content_if_exists(sink)
        return [
            heading,
            MarkdownHeading("Source File", self.level + 2),
            MarkdownCode(source_content, self.pattern.language),
            MarkdownHeading("Sink File", self.level + 2),
            MarkdownCode(sink_content, self.pattern.language),
        ] if source_content and sink_content else []

    def _instance_properties(self) -> list:
        # Generates the table of instance properties.
        properties_dict = {
            "category": [self.current_instance.properties_category],
            "feature_vs_internal_api": [self.current_instance.properties_feature_vs_internal_api],
            "input_sanitizer": [utils.translate_bool(self.current_instance.properties_input_sanitizer)],
            "source_and_sink": [utils.translate_bool(self.current_instance.properties_source_and_sink)],
            "negative_test_case": [utils.translate_bool(self.current_instance.properties_negative_test_case)]
        }
        return [
            MarkdownHeading("Instance Properties", self.level + 1),
            MarkdownTable(properties_dict)
        ]

    def _instance_more(self) -> list:
        # generates the instance more section
        ret = []
        for f in self.instance_more_structure:
            ret += f()
        return [MarkdownCollapsible(ret, MarkdownString("<b>More</b>"))]

    def _compile(self) -> list:
        # Generates the compile section for an instance.
        compile = self.current_instance.compile_binary
        content = self._get_file_content_if_exists(compile)
        binary = MarkdownCode(content, utils.get_language_by_file_ending(compile))
        return [MarkdownCollapsible([binary], MarkdownHeading("Compile", self.level + 1))] if content else []

    def _discovery(self) -> list:
        # Generates the 'discovery' section for an instance.
        desc = self.current_instance.discovery_notes
        desc = MarkdownString(self._get_file_content_if_exists(desc))
        rule_path = self.current_instance.discovery_rule
        rule = self._get_file_content_if_exists(rule_path)
        # get only necessary content
        rule = re.sub(r"@main def main\(name .*{.*$", "", rule, flags=re.M)
        rule = re.sub(r"importCpg.*$", "", rule, flags=re.M)
        rule = re.sub(r"println\(.*\).*$", "", rule, flags=re.M)
        rule = re.sub(r"delete;.*$", "", rule, flags=re.M)
        rule = "".join(rule.rsplit("}", 1)) # remove the last }
        rule = "\n".join([l.strip() for l in rule.split("\n")]).strip()
        rule = (
            MarkdownCode(rule, utils.get_language_by_file_ending(rule_path))
            if rule_path
            else MarkdownString("No discovery rule yet.")
        )
        discovery_table = {
            "discovery method": [self.current_instance.discovery_method],
            "expected accuracy": [
                self.current_instance.discovery_rule_accuracy
            ],
        }
        discovery_table = MarkdownTable(discovery_table)
        return [
            MarkdownCollapsible(
                [desc, rule, discovery_table],
                MarkdownHeading("Discovery", self.level + 1),
            )
        ]

    def _measurement(self) -> list:
        # Generates the 'measurement' section for an instance.
        if not self.measurements:
            return []
        instance_measurements = self.measurements / self.pattern.path.name / self.current_instance.name
        if not instance_measurements.exists():
            logger.error(f"{self.log_prefix}Could not find `measurement` for {self.current_instance}")
            return []
        measurement_table = {}
        has_measurement = False
        dates = []
        ground_truth = self.current_instance.expectation_expectation
        for json_file in utils.list_files(instance_measurements, ".json"):
            current_json = utils.read_json(json_file)
            for c_dict in current_json:
                try:
                    measurement = Measurement.init_from_measurement_dict(c_dict)
                except MeasurementInvalid:
                    logger.warning(f"{self.log_prefix}Could not fetch measurement in {current_json}")
                    continue
                has_measurement = True
                tool = f"1::{self._mask(measurement.tool.lower())}"
                date = datetime.strptime(measurement.date, "%Y-%m-%d %H:%M:%S").strftime("%d %b %Y")
                dates += [date]
                sast_tool_result = utils.translate_bool(not (measurement.result ^ ground_truth))
                try:
                    measurement_table[tool] += [(sast_tool_result, date)]
                    measurement_table[tool] = sorted(
                        measurement_table[tool],
                        key=lambda tup: datetime.strptime(tup[1], "%d %b %Y"),
                    )
                except KeyError:
                    measurement_table[tool] = [(sast_tool_result, date)]
        if not has_measurement:
            return []
        measurement_table, sorted_dates = self._format_measurements(measurement_table, dates)
        measurement_table["0::Tool"] = sorted_dates
        measurement_table["2::Ground Truth"] = [utils.translate_bool(ground_truth)] * len(sorted_dates)
        return [
            MarkdownCollapsible(
                [MarkdownTable(measurement_table)],
                MarkdownHeading("Measurement", self.level + 1),
                is_open=True,
            )
        ]

    def _remediation(self) -> list:
        # Generates the 'remediation' section for an instance.
        note = self.current_instance.remediation_notes
        note = MarkdownString(self._get_file_content_if_exists(note))
        transformation = self.current_instance.remediation_transformation
        transformation = MarkdownString(self._get_file_content_if_exists(transformation))
        modeling_rule = self.current_instance.remediation_modeling_rule
        modeling_rule = MarkdownString(self._get_file_content_if_exists(modeling_rule))
        if any([note, transformation, modeling_rule]):
            note = [
                note
                if note
                else MarkdownString(
                    "Can you think of a transformation, that makes this tarpit less challenging for SAST tools?"
                )
            ]
            transformation = (
                [MarkdownHeading("Transformation", self.level + 2), transformation]
                if transformation
                else []
            )
            modeling_rule = (
                [MarkdownHeading("Modeling Rule", self.level + 2), modeling_rule]
                if modeling_rule
                else []
            )
            return [
                MarkdownCollapsible(
                    note + transformation + modeling_rule,
                    MarkdownHeading("Remediation", self.level + 1),
                )
            ]
        return []

    def _get_file_content_if_exists(self, path_to_file: Path) -> str:
        if not path_to_file:
            return ""
        potential_file_path = Path(self.current_instance.path / path_to_file).resolve()
        if " " not in str(path_to_file) and potential_file_path.is_file():
            with open(potential_file_path, "r") as in_file:
                return "".join(in_file.readlines()).strip()
        return path_to_file if path_to_file else ""

    def _mask(self, value_to_mask: str):
        if value_to_mask in self.mask_dict.keys():
            return self.mask_dict[value_to_mask]
        return value_to_mask

    def _format_measurements(self, tool_measurement_dict: dict, dates: list) -> tuple:
        """Formats the measurements in the wanted table format:
        |        | Tool1  | Tool2  |
        |--------+--------+--------|
        | Date1  | yes    | no     |
        Args:
            tool_measurement_dict (dict): dict containing measurement results and date as a list of tuple for each tool.
            dates (list): a list of measurement dates.
        Returns:
            tuple(dict, list): dict of all tools and their measurement results (one column) and a list of sorted measurement dates (first column)
        """
        dates_sorted = sorted(list(set(dates)))
        formatted_measurement_table = {}
        for tool, measurements in tool_measurement_dict.items():
            formatted_measurements = []
            current_measurement = measurements.pop(0)
            for date in dates_sorted:
                if current_measurement[1] == date:
                    formatted_measurements += [current_measurement[0]]
                    if len(measurements):
                        current_measurement = measurements.pop(0)
                    else:
                        break
                else:
                    formatted_measurements += [""]
            formatted_measurement_table[tool] = formatted_measurements
        return formatted_measurement_table, dates_sorted

    def generate_md(self) -> list:
        ret = []
        for idx, self.current_instance in enumerate(self.pattern.instances):
            instance_md_elements = []
            for f in self.instance_structure:
                instance_md_elements += f()
            if self.has_multiple_instances:
                ret += [
                    MarkdownCollapsible(
                        instance_md_elements[1:], instance_md_elements[0], idx == 0
                    )
                ]
            else:
                ret = instance_md_elements
        return ret